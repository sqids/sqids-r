#' A function to create a list of sqids settings
#'
#' @param alphabet String of characters for IDs
#' @param min_length Minimum length for IDs
#' @param blocklist Vector of strings to block in generated IDs
#' @returns A list of parameters to configure encoding and decoding
#' @export
#'
sqids_options = function(
    alphabet = DEFAULT_ALPHABET,
    min_length = DEFAULT_MIN_LENGTH,
    blocklist = DEFAULT_BLOCKLIST
) {
  # Compare raw byte count to character count.
  alphabet_blob <- charToRaw(alphabet)
  if (length(alphabet_blob) != nchar(alphabet)) {
    stop("Alphabet cannot contain multibyte characters.")
  }

  # Check the length of the alphabet.
  if (nchar(alphabet) < 3) {
    stop("Alphabet lenght must be at least 3.")
  }

  # Check that all characters are unique.
  alphabet_set <- unique(unlist(strsplit(alphabet, split="")))
  if (length(alphabet_set) != nchar(alphabet)) {
    stop("Alphabet must contain unique characters.")
  }

  # Test minimum length is within bounds.
  min_length_limit <- 255
  if (!is.numeric(min_length) || min_length < 0 || min_length > min_length_limit) {
    stop("Minimum length must be between 0 and ", min_length_limit, ".")
  }

  # Clean up the blocklist:
  # 1. All words should be lowercase.
  # 2. No words less than 3 characters.
  # 3. Remove words that have characters not in our alphabet.
  filtered_blocklist = vector()
  for (word in blocklist) {
    if (nchar(word) >= 3) {
      lowercased <- tolower(word)

      word_chars <- unlist(strsplit(lowercased, split=""))
      intersection <- word_chars %in% tolower(alphabet_set)

      if (length(intersection[intersection == TRUE]) == length(word_chars)) {
        filtered_blocklist <- c(filtered_blocklist, lowercased)
      }
    }
  }

  shuffled_alphabet <- shuffle(alphabet)

  return(list(
    alphabet = shuffled_alphabet,
    min_length = min_length,
    blocklist = filtered_blocklist
  ))
}

#' Encodes a vector of unsigned integers into an ID
#'
#' These are the cases where encoding might fail: \cr
#' - One of the numbers passed is smaller than 0 or greater than ".Machine$integer.max" \cr
#' - An n-number of attempts has been made to re-generated the ID, where n is alphabet length + 1
#'
#' @param numbers Vector of non-negative numbers to encode
#' @param options List of settings generated by sqids_options
#' @returns ID string
#' @export
#'
encode = function(numbers, options) {
  # Return empty string if no numbers are passed.
  if (length(numbers) == 0) {
    return('')
  }

  # Don't allow out-of-range numbers.
  numbers_intersection <- numbers[numbers >= 0 & numbers <= max_value()]
  if (length(numbers_intersection) != length(numbers)) {
    stop("Encoding supports numbers between 0 and ", max_value(), ".")
  }

  return(encode_numbers(numbers, options))
}

#' Internal function that encodes a vector of unsigned integers into an ID
#'
#' @param numbers Non-negative integers to encode into an ID
#' @param options List of settings generated by sqids_options
#' @param increment Internal number used to modify the 'offset' variable in order to re-generate the ID
#' @returns ID string
#'
encode_numbers = function(numbers, options, increment = 0) {
  alphabet <- options$alphabet

  # If increment is larger than our alphabet, we've reached max attempts.
  if (increment > nchar(alphabet)) {
    stop("Reached max attempts to re-generate the ID.")
  }

  find_offset <- function(acc, value, idx) {
    charIdx <- value %% nchar(alphabet) + 1
    charAtIdx <- substr(alphabet, charIdx, charIdx)
    utf8ToInt(charAtIdx) + idx + acc - 1
  }

  # Get a semi-random offset from input numbers.
  offset <- reduce(numbers, find_offset, length(numbers)) %% nchar(alphabet)

  # If there is a non-zero 'increment', it's an internal attempt to re-generate the ID.
  offset <- (offset + increment) %% nchar(alphabet) + 1

  alphabet <- split_and_reverse(alphabet, offset)

  # `prefix` is the last character in the generated ID, used for randomization.
  prefix <- substr(alphabet, nchar(alphabet), nchar(alphabet))

  # Final ID will always have the `prefix` character at the beginning.
  ret <- c(prefix)

  # Encode the input array.
  for (i in seq_along(numbers)) {
    # The first character in the alphabet is reserved for the `seperator`
    alphabet_wo_seperator <- substr(alphabet, 2, nchar(alphabet))

    ret <- c(ret, to_id(numbers[i], alphabet_wo_seperator))

    # If not the last number.
    if (i < length(numbers)) {
      # `separator` character is used to isolate numbers within the ID.
      ret <- c(ret, substr(alphabet, 1, 1))

      # Shuffle on every iteration.
      alphabet <- shuffle(alphabet)
    }
  }

  # Join all the parts to form an ID.
  id <- paste0(ret, collapse="")

  # Handle `min_length` requirement, if ID is too short.
  if (options$min_length > nchar(id)) {
    # Append a seperator.
    id <- paste0(id, substr(alphabet, 1, 1), collapse="")

    # Keep appending `separator` + however much alphabet is needed.
    # For decoding: two separators next to each other is what tells us the rest are junk characters.
    while (options$min_length - nchar(id) > 0) {
      alphabet <- shuffle(alphabet)
      padding_length <- min(options$min_length - nchar(id), nchar(alphabet))
      id <- paste0(id, substr(alphabet, 1, padding_length), collapse="")
    }
  }

  # If `id` has a blocked word, restart with `increment` += 1.
  if (is_blocked_id(id, options$blocklist)) {
    id <- encode_numbers(numbers, options, increment + 1)
  }

  return(id)
}

#' Decodes an ID back into a vector of unsigned integers
#'
#' These are the cases where the return value might be an empty array: \cr
#' - Empty ID / empty string \cr
#' - Non-alphabet character is found within ID
#'
#' @param id Encoded ID
#' @param options List of settings generated by sqids_options
#' @returns Vector of unsigned integers
#' @export
#'
decode = function(id, options) {
  ret = vector()

  # If `id` is an empty string, return an empty vector (R can't return empty vectors).
  if (id == '') {
    return(NULL)
  }

  # If a character is not in the alphabet, return an empty vector.
  alphabet <- options$alphabet
  alphabet_chars = unlist(strsplit(alphabet, split=""))
  id_chars = unlist(strsplit(id, split=""))
  intersection <- id_chars %in% alphabet_chars
  if (length(intersection[intersection == TRUE]) != length(id_chars)) {
    return(ret)
  }

  # First character is always the `prefix`.
  prefix <- substr(id, 1, 1)

  # `offset` is the semi-random position that was generated during encoding.
  offset <- match(prefix, unlist(strsplit(alphabet, split='')))

  alphabet <- split_and_reverse(alphabet, offset)

  # Now it's safe to remove the prefix character from ID, it's not needed anymore.
  id <- substr(id, 2, nchar(id))

  # Decode.
  while (nchar(id)) {
    seperator <- substr(alphabet, 1, 1)

    # We need the first part to the left of the separator to decode the number.
    chunks <- unlist(strsplit(id, split=seperator))

    # strsplit() doesn't include a blank value when the seperator is at either end of the
    # subject string. This check adds a LHS or RHS empty string to mimic the JS .split()
    # behavior.
    if (endsWith(id, seperator)) {
      chunks <- c(chunks, "")
    }
    if (startsWith(id, seperator)) {
      chunks <- c("", chunks)
    }

    if (length(chunks)) {
      # If the chunk is empty, we are done (the rest are junnk characters).
      if (chunks[1] == "") {
        break
      }

      # Decode the number without using the `separator` character.
      alphabet_wo_seperator <- substr(alphabet, 2, nchar(alphabet))
      ret <- c(ret, to_number(chunks[1], alphabet_wo_seperator))

      # If this ID has multiple numbers, shuffle the alphabet because that's what encoding function did.
      if (length(chunks) > 1) {
        alphabet <- shuffle(alphabet)
      }
    }

    # `id` is now going to be everything to the right of the `separator`.
    id <- paste0(chunks[-1], collapse=seperator)
  }

  return(ret)
}

#' Internal function to consistently shuffle alphabet
#'
#' @param alphabet Alphabet string
#' @returns Shuffled alphabet string
#'
shuffle = function(alphabet) {
  chars = unlist(strsplit(alphabet, split=""))
  for (i in seq_along(chars)) {
    if (i == length(chars)) {
      break
    }

    j <- length(chars) - i + 1
    r <- (i * j + utf8ToInt(chars[i]) + utf8ToInt(chars[j])) %% length(chars) + 1

    # Swap characters.
    temp <- chars[i]
    chars[i] <- chars[r]
    chars[r] <- temp
  }

  shuffled <- paste0(chars, collapse="")

  return(shuffled)
}

#' Internal function to convert a number to it's respective character
#'
#' @param num Integer to convert
#' @param alphabet Alphabet string integer is mapped to
#' @return ID string
#'
to_id = function(num, alphabet) {
  id <- c()
  chars <- unlist(strsplit(alphabet, ""))

  res <- num
  repeat {
    id <- c(chars[res %% length(chars) + 1], id)
    res <- floor(res / length(chars))

    if (res == 0) {
      break
    }
  }

  return(paste0(id))
}

#' Internal function to convert a ID string to it's respective number
#'
#' @param id ID string to convert
#' @param alphabet Alphabet string ID was mapped from
#' @returns Unsigned integer value
#'
to_number <- function(id, alphabet) {
  chars <- unlist(strsplit(alphabet, split=""))

  convert <- function(acc, value, idx) {
    acc * length(chars) + match(value, unlist(strsplit(alphabet, split=''))) - 1
  }

  return(reduce(unlist(strsplit(id, "")), convert, 0))
}

#' Internal function to check if generated ID includes blocked word
#'
#' @param id ID string
#' @param blocklist Vector of blocked strings
#' @returns Boolean
is_blocked_id = function(id, blocklist) {
  # Don't use any blocklist when empty blocklist is passed.
  if (is.null(blocklist)) {
    return(FALSE)
  }

  id <- tolower(id)

  for (word in blocklist) {
    # Ignore words longer than the ID.
    if (nchar(word) <= nchar(id)) {
      if (nchar(id) <= 3 || nchar(word) <= 3) {
        # Short words must match completely.
        if (id == word) {
          return(TRUE)
        }
      } else if (grepl("\\d", word)) {
        # Words with leet speak replacements are visible mostly on the ends of the ID.
        if (startsWith(id, word) || endsWith(id, word)) {
          return(TRUE)
        }
      } else if (grepl(word, id, fixed=TRUE)) {
        return(TRUE)
      }
    }
  }

  return(FALSE)
}

#' Internal function to quickly access biggest possible integer value
#'
#' @returns Maximum integer value
max_value = function() {
  return(as.integer(.Machine$integer.max))
}

#' Internal function to rearrange the alphabet at an offset, then reverse it.
#'
#' Before reversing the input is split based off the offset position and the
#' first half is put after the second.
#'   - First half: [1, offset - 1)
#'   - Second half: [offset, nchar(alphabet)]
#'
#' @param alphabet Alphabet string
#' @param offset Integer offset of start of second half
split_and_reverse = function(alphabet, offset) {
  # Rearrange alphabet so that the second-half goes in front of the first-half.
  first_half <- substr(alphabet, 1, offset - 1)
  second_half <- substr(alphabet, offset, nchar(alphabet))
  alphabet <- paste0(second_half, first_half, collapse="")

  # Reverse alphabet (otherwise for [0, x] `offset` and `separator` will be the same char)
  alphabet <- paste0(rev(unlist(strsplit(alphabet, split=""))), collapse="")
}

reduce = function(vec, callback, initial) {
  result <- initial
  for (i in seq_along(vec)) {
    result <- callback(result, vec[i], i)
  }

  return(result)
}
